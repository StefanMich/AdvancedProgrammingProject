\input{preamble}


\title{Templates in C++ }
\author{Stefan Micheelsen \\smiche11@student.aau.dk \\Studentnumber: 20112707}
\date{1. April 2015}

\newcommand{\file}[1]
{
	\textit{\color{gray} ``#1''}
}

\begin{document}



\maketitle

This report will describe my work on template programming in C++.
The main focus will be a comparison with the experience I have with generics in C\#.
A lot of the work in the report will be experiments with features that are not present in the C\# language and are therefore not known to me.
There is no main program as such, but there are several methods in the \file{Eksamensprojekt.cpp} that explores the classes and templates that have been created.


\section{Templates in C++}
Templates is the C++ implementation of what is called generic programming.
Generic programming is a technique that aims a making it possible to implement general algorithms. \cite[p.~700]{stroustrup2013c++}.

Without generic programming it would be necessary to write a variation of a list for each data type you would want to put in the list.
Generic programming provides a tool to provide functionality for each data type, without having to write each of them by hand.

In C\# generic types are compiled to a annotated version in the intermediate code, and the specialized type is generated in the runtime when it is needed\cite{genericruntime}.
On the other hand templates in C++ are generated from the principle of duck typing, meaning that the use of a type parameter determines the choice of implementation and thus the behavior of a method.\cite[p.~700]{stroustrup2013c++}.

\section{Overview}
In order to experiment with templates in C++ I choose to implement two very simple data structures, the stack and the binary search tree.
Because the emphasis is on templates and not the workings of these data structures, not all features are implemented, only what is necessary in order to demonstrate the power of templates.
The implementations are taken from \citet{algo}.

\section{The first template}
When designing a template Bjarne Stroustrup recommends starting out by implementing the class without type parameters\cite[p.~670]{stroustrup2013c++}. 
I therefore started out by investigating the stack data structure and implemented it to be a stack of integers.
The initial implementation can be found in \file{StackOfInt.h} and \file{StackOfInt.cpp}.

Looking at this relatively simple class it should be a simple job to use a type parameter instead of the hard coded integer type.

The implementation of the stack with type parameters can be seen in \file{StackTemplate.h}

\begin{lstlisting}
template<typename T>
void StackTemplate<T>::Push(T i) (*@)\label{usageOfT}@*)
{
	topIndex++;
	arr[topIndex] = i;
}
\end{lstlisting}

The line \lstinline|template<typename T>| tells the C++ compiler that the following is a template where all instances of \texttt{T} should be changed with the specified type in any template instantiation.
In the implementation of the Push method the \texttt{T} can be seen used in line \ref{usageOfT} where the \lstinline|StackTemplate<T>| specifies that this implementation of Push belongs to the template of the stack containing one type parameter.
The T used as the argument specifies that the argument needs to be of the same type as the type used for the stack. 

With the first version of the template of a stack in place, the process of ``lifting'' can continue . 
Lifting is the act of taking an implementation from a concrete level to a general level while maintaining high performance\cite[p.~700]{stroustrup2013c++}.

\section{Template arguments}
The basic use of templates is extend an implementation with type parameters.
Templates can also use other parameters, expanding the possibilities of templates \cite[p.~722]{stroustrup2013c++}.
One of these possibilities is to use a value as a template parameter.
This can be used to define sizes of the template. \cite[p.~724]{stroustrup2013c++}

In the initial implementation of the stack I chose not to make it dynamically expand when adding elements.
This means that its size is fixed to 16 elements.
This is of course inefficient if you only insert 2 elements, and insufficient if you need to insert 20 elements.
A possible solution is to use a value parameter to specify how big the stack needs to be.

\begin{lstlisting}
template<typename T, int entries>
StackTemplateValueArgument<T, entries>::StackTemplateValueArgument() : topIndex{ -1 }
{
	arr = new T[entries];
}
\end{lstlisting}


The implementation of the stack with value parameters can be found in \file{StackTemplateValueArgument.h}.
It still uses the \texttt{T} as type parameter but now also has an \texttt{entries} parameter that specifies the size of the stack.
Shown is the constructor where the array is created, where the value parameter is used to create the array of type \texttt{T} with \texttt{entries} elements

This implementation will be efficient in cases where the user knows how many elements needs to be in the stack.

This feature is not present at all in C\# generics which is restricted to only type parameters \cite{cgenerics} making it impossible to reach a similar result.

\section{Specialization}
Looking at the templates written for the stack it seems at this point to be a very generic implementation of the simple data structure, but it can be lifted even more.

Consider a stack of integers and a stack of boolean values.
In principle the same thing should happen.
Push an element on the stack, pop an element, the same thing happens independent of the data type.
The problem is that a boolean is stored in a byte even though it can be expressed as a single bit.

With this issue in mind I created a \texttt{bool} specialization of the stack.
It is contained in \file{StackTemplateBoolSpecialization.h}.
Here I implemented the stack to store the boolean values as a single byte instead of in a byte for each.

\begin{lstlisting}
bool StackTemplateBoolSpecialization<bool>::Top()
{
	int positionInRepr = topIndex / 8;
	int positionInByte = topIndex % 8;

	char entry = arr[positionInRepr] << (positionInByte);
	entry = entry >> 7;
	bool poppedEntry = (bool)entry;

	return poppedEntry;
}
\end{lstlisting}

Presented is a the \lstinline|Top()| method from the boolean stack specialization.
As this is the boolean specialization of the stack the class name is qualified with \texttt{bool}. 
The current top entry is found by shifting the bits first to the left, removing the bits of the rest of the stack and then 7 to the right for the boolean value to settle at the rightmost bit, making it possible to read the boolean value from it.

A simple experiment shows that the normal stack implementation with space for 16 boolean take up 20 bytes of space, while the specialization only uses 8 bytes.
This experiment can be found in the \lstinline|StackTemplateBoolSpecializationTest()| test method that can be found in the \file{Eksamensprojekt.cpp} file.

Specialization is a feature in C++ template programming that makes it possible to make specialized implementations for certain arguments.
It is possible to partially specialize for a subset of types, like pointers, and it is possible to fully specialize to a type like bool as has been demonstrated in the above. \cite[p.~730]{stroustrup2013c++}.

Again this is a feature that C\# simply does not have. 
In C\# generics you can provide one implementation, and that implementation will be used for every type parameter that will be provided.\cite{diff}

\section{Concepts}


\bibliography{bib}
\bibliographystyle{plain}

\end{document}